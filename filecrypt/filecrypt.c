/*
 * =====================================================================================
 *
 *       Filename: filecrypt.c
 *
 *    Description: Simple file (en|de)cryption tool based on 256bit AES (ofb) 
 *
 *        Version: 1.0
 *        Created: Sun, 12.12.2010 - 14:18:21
 *  Last modified: Sat, 14.05.2011 - 17:25:14
 *       Revision: none
 *       Compiler: gcc -std=c99 -Wall -D_XOPEN_SOURCE=600 -O2 -g -lcrypto
 *
 *         Author: Ulli Goschler, siulgosc@stud.informatik.uni-erlangen.de
 *
 * =====================================================================================
 */

#define AESKEYLEN 32          /* Key length of aes-256-ofb */
#define HMACKEYLEN 32         /* Key length for hmac */
#define SALTLEN 20            /* Salt for PBKDF2 to derive key from pw */
#define IVLEN 16              /* IV for aes-256-ofb, 128 bit */
#define HMACLEN 20            /* HMACLEN is 160 bit, as it shall base on SHA1 */
#define PBKDF2ITERATIONS 2000 /* Number of iterations */
#define PWLEN 30


#include <openssl/evp.h>
#include <openssl/rand.h>
#include <openssl/hmac.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>

static void usageError() {
	fprintf(stderr, "Usage: ./filecrypt enc <plain.txt> <enc.txt>\n./filecrypt dec <enc.txt> <plain.txt>\n");
	exit(EXIT_FAILURE);
}

int main(int argc, char **argv) {
	if(argc != 4)
		usageError();
/* 
 * Encrypted Data Scheme:
 * ---------------------------------
 * | Data       | Salt | IV | HMAC |
 * ---------------------------------
 *
 *  PBKDF2 creates with SALT and PASSWORD a key.
 *  The key is divided into 2 subkeys.
 *      first part is used for fileencryption (EVP_CipherInit_ex)
 *      second part is used for HMAC 
 *	Both, the encrypted and the decrypted files are stored (chmod) 600
 *
 * */
	
	char password[PWLEN];           // user pw 
	unsigned char salt[SALTLEN];    // random generated salt
	unsigned char iv[IVLEN];        // IV 
	unsigned char 
		completeKey[AESKEYLEN +
			        HMACKEYLEN];    // stores the complete key generated by PBKDF2; Will be divided into 2 subkeys
	unsigned char key1[AESKEYLEN];  // first part of completeKey 
	unsigned char key2[HMACKEYLEN]; // second part
	EVP_CIPHER_CTX cctx;
	unsigned char *dataToEnc = NULL;
	unsigned char *dataToDec = NULL;
	struct stat file;
	int fileSize;
	int passwordLen = 0;

	if(0 != stat(argv[2], &file)) {
		perror("stat");
		exit(EXIT_FAILURE);
	}
	fileSize = file.st_size;
	int fildes = 0;
	if(-1 == (fildes = open(argv[2], O_RDONLY))) {
		perror("open");
		exit(EXIT_FAILURE);
	}


	if(0 == strcmp(argv[1], "enc")) {
		unsigned char dataEnc[fileSize];
		unsigned char encHeader[fileSize+SALTLEN+IVLEN];
		unsigned char *hmac = NULL;

		/* get enc file and map into address space */
		dataToEnc = mmap(NULL, fileSize, PROT_READ, MAP_SHARED, fildes, 0);
		if(NULL == dataToEnc) {
			fprintf(stderr, "Couldn't map input file\n");
			exit(EXIT_FAILURE);
		}
		
		/* read password, provided by user*/
		if(0 != EVP_read_pw_string(password, PWLEN, "Enter Password: ", 1)) {
			perror("EVP_read_pw_string");
			exit(EXIT_FAILURE);
		}
		for(; password[passwordLen] != '\0'; passwordLen++);

		/* fill SALT with (strong) Random */
		if(1 != RAND_bytes(salt, SALTLEN)) {
			perror("RAND_bytes");
			exit(EXIT_FAILURE);
		}
		/* create the key used for encryption and MAC */
		if(1 != PKCS5_PBKDF2_HMAC_SHA1(password, passwordLen, salt, SALTLEN, PBKDF2ITERATIONS, HMACKEYLEN + AESKEYLEN, completeKey)) {
			perror("PKCS5_PBKDF2_HMAC_SHA1");
			exit(EXIT_FAILURE);
		}

		/* split the key into 2 subkeys, used for HMAC and as part of IV */
		memcpy(key1, completeKey, AESKEYLEN);
		memcpy(key2, completeKey+AESKEYLEN, HMACKEYLEN);

		/* fill iv with random data */
		if(1 != RAND_bytes(iv, IVLEN)) {
			perror("RAND_bytes");
			exit(EXIT_FAILURE);
		}
		/* init aes encryption */
		EVP_CIPHER_CTX_init(&cctx);
		if(0 == EVP_CipherInit_ex(&cctx, EVP_aes_256_ofb(), NULL, key1, iv, 1)) {
			perror("EVP_CipherInit_ex");
			exit(EXIT_FAILURE);
		}
		if(0 == EVP_CipherUpdate(&cctx, dataEnc, &fileSize, dataToEnc, fileSize)) {
			EVP_CIPHER_CTX_cleanup(&cctx);
			perror("EVP_CipherUpdate");
			exit(EXIT_FAILURE);
		}
		EVP_CIPHER_CTX_cleanup(&cctx);
		
		/* prepare write to disk */
		int encFileOut = 0;
		if(-1 == (encFileOut = open(argv[3], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR))) {
			perror("open write");
			exit(EXIT_FAILURE);
		}
		/* store the IV and Salt in the encryption Header */
		memcpy(encHeader, dataEnc, fileSize);
		memcpy(encHeader+fileSize, salt, SALTLEN);
		memcpy(encHeader+fileSize+SALTLEN, iv, IVLEN);


		/* create the MAC */
		hmac = HMAC(EVP_sha1(), key2, HMACKEYLEN, encHeader, fileSize+SALTLEN+IVLEN, NULL, NULL); 
		if(hmac == NULL) {
			fprintf(stderr, "Creating HMAC failed");
			exit(EXIT_FAILURE);
		}

		/* write encrypted Data and Header to disk  */
		write(encFileOut, encHeader, fileSize+SALTLEN+IVLEN);
		write(encFileOut, hmac, HMACLEN); 

		close(fildes);
		close(encFileOut);

	} else if (0 == strcmp(argv[1], "dec")) {

		unsigned char dataDec[fileSize-HMACLEN-IVLEN-SALTLEN];
		unsigned char encData[fileSize-HMACLEN-IVLEN-SALTLEN];
		unsigned char encHMAC[HMACLEN];
		unsigned char *hmac = NULL;
		
		dataToDec = mmap(NULL, fileSize, PROT_READ, MAP_SHARED, fildes, 0);
		if(NULL == dataToDec) {
			fprintf(stderr, "Couldn't map Input File\n");
			exit(EXIT_FAILURE);
		}
	

		/* extract "header" from the enc file */
		int offset = fileSize-HMACLEN;
		memcpy(encHMAC, dataToDec+offset, HMACLEN);     /* | data | salt | iv | hmac    */
		offset -= IVLEN;
		memcpy(iv, dataToDec+offset, IVLEN);            /* | data | salt | iv           */
		offset -= SALTLEN;
		memcpy(salt, dataToDec+offset, SALTLEN);        /* | data | salt                */
		memcpy(encData, dataToDec, offset);             /* | data                       */

		/* read password */
		if(0 != EVP_read_pw_string(password, PWLEN, "Enter Password: ", 0)) {
			perror("EVP_read_pw_string");
			exit(EXIT_FAILURE);
		}
		for(; password[passwordLen] != '\0'; passwordLen++);
		
		if(1 != PKCS5_PBKDF2_HMAC_SHA1(password, passwordLen, salt, SALTLEN, PBKDF2ITERATIONS, HMACKEYLEN + AESKEYLEN, completeKey)) {
			perror("PKCS5_PBKDF2_HMAC_SHA1");
			exit(EXIT_FAILURE);
		}

		memcpy(key1, completeKey, AESKEYLEN);
		memcpy(key2, completeKey+AESKEYLEN, HMACKEYLEN);
		
		hmac = HMAC(EVP_sha1(), key2, HMACKEYLEN, dataToDec, offset+IVLEN+SALTLEN, NULL, NULL); 
		if(hmac == NULL) {
			fprintf(stderr, "Creating HMAC failed");
			exit(EXIT_FAILURE);
		}
		/* DEBUG
		printf("generated HMAC: ");
		for(int i = 0; i < HMACLEN; i++) 
			printf("%X", hmac[i]);

		printf("\nfile HMAC:      ");
		for(int i = 0; i < HMACLEN; i++) 
			printf("%X", encHMAC[i]); 
		*/

		/* compare generated HMAC with stored HMAC */
		if(0 != memcmp(encHMAC, hmac, HMACLEN)) {
			fprintf(stderr,"Wrong Password\n");
			exit(EXIT_FAILURE);
		}

		EVP_CIPHER_CTX_init(&cctx);
		if(0 == EVP_CipherInit_ex(&cctx, EVP_aes_256_ofb(), NULL, key1, iv, 0)) {
			perror("EVP_CipherInit_ex");
			exit(EXIT_FAILURE);
		}
		if(0 == EVP_CipherUpdate(&cctx, dataDec, &offset, encData, offset)) {
			EVP_CIPHER_CTX_cleanup(&cctx);
			perror("EVP_CipherUpdate");
			exit(EXIT_FAILURE);
		}
		EVP_CIPHER_CTX_cleanup(&cctx);

		int encFileOut = 0;
		if(-1 == (encFileOut = open(argv[3], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR))) {
			perror("open write");
			exit(EXIT_FAILURE);
		}
		write(encFileOut, dataDec, offset); 

		close(encFileOut);
		close(fildes);
	} else 
		usageError();

	return 0;
}

